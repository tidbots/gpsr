#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
gpsr_parser.py

RoboCup@Home GPSR command parser (text -> steps).

- ASRは別段（Whisper等）。ここは「テキストをGPSR向けステップに解析」する役。
- it/them 参照解決や slot 整形は gpsr_parser_node.py 側でやる前提。
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict, Any, Optional, Tuple
import re


# ================= 正規化・分割ユーティリティ =================

def normalize_text(text: str) -> str:
    t = (text or "").strip().lower()
    t = t.replace("’", "'").replace("`", "'")
    t = re.sub(r"[!?]", ".", t)
    t = re.sub(r"\s+", " ", t).strip()
    # polite prefix
    t = re.sub(r"^(please\s+)", "", t).strip()
    return t


def split_into_clauses(text: str) -> List[str]:
    """
    GPSR向け：then / and then を主な句切りにする。
    'and' 単体は名詞句や修飾の中で頻出なので原則として句切りに使わない。

    ただし実データでは以下のような "and" 連結が多いので、
    **特定パターンに限って** and を then に正規化してから分割する：
      - meet/introduce/salute/say hello ... and (follow|lead|guide|escort|answer|tell|say)
      - go/navigate ... and (follow|lead|guide|escort|answer|tell|say)
    """
    t = normalize_text(text).strip().strip(".")
    t = re.sub(r"\band then\b", " then ", t)

    # selective 'and' -> 'then' for verb-to-verb chaining
    t = re.sub(
        r"\b(meet|introduce yourself|salute|say hello|go|navigate)\b(.+?)\band\s+"
        r"(follow|lead|guide|escort|answer|tell|say)\b",
        r"\1\2 then \3",
        t,
    )

    parts = [p.strip() for p in re.split(r"\bthen\b", t) if p.strip()]
    return parts


def best_match(token: str, candidates: List[str]) -> Optional[str]:
    """
    単純な最長一致。token は正規化済み、candidates も lower を前提。
    """
    token = token.strip().lower()
    if not token:
        return None
    if token in candidates:
        return token
    hits = [c for c in candidates if c in token]
    if hits:
        hits.sort(key=len, reverse=True)
        return hits[0]
    hits = [c for c in candidates if token in c]
    if hits:
        hits.sort(key=len, reverse=True)
        return hits[0]
    return None


# ================= データ構造 =================

@dataclass
class Place:
    name: str
    is_room: bool = False
    is_placement: bool = True


@dataclass
class GpsrStep:
    action: str
    fields: Dict[str, Any]


@dataclass
class ParseResult:
    ok: bool
    need_confirm: bool
    intent_type: str
    command_kind: str
    steps: List[GpsrStep]

    def to_dict(self) -> Dict[str, Any]:
        # NOTE: Place は dataclass のまま返す（json化は eval 側で default を使うのが安全）
        return {
            "ok": self.ok,
            "need_confirm": self.need_confirm,
            "intent_type": self.intent_type,
            "command_kind": self.command_kind,
            "steps": [{"action": s.action, "args": s.fields} for s in self.steps],
        }


# ================= パーサ本体 =================

class GpsrParser:
    def __init__(
        self,
        person_names: List[str],
        location_names: List[str],
        placement_location_names: List[str],
        room_names: List[str],
        object_names: List[str],
        object_categories_plural: List[str],
        object_categories_singular: List[str],
    ):
        self.person_names = sorted(set([normalize_text(n) for n in person_names if n]))
        self.location_names = sorted(set([normalize_text(n) for n in location_names if n]))
        self.placement_location_names = sorted(set([normalize_text(n) for n in placement_location_names if n]))
        self.room_names = sorted(set([normalize_text(n) for n in room_names if n]))
        self.object_names = sorted(set([normalize_text(n).replace("_", " ") for n in object_names if n]))
        self.object_categories_plural = sorted(set([normalize_text(n) for n in object_categories_plural if n]))
        self.object_categories_singular = sorted(set([normalize_text(n) for n in object_categories_singular if n]))

        self.find_verbs = ["find", "look for", "locate", "search for"]
        self.tell_prefixes = ["tell me", "tell"]
        self.count_prefixes = ["tell me", "how many", "tell"]
        self.go_verbs = ["go to", "navigate to", "move to"]

    # ---------- vocab matchers ----------

    def _strip_articles(self, s: str) -> str:
        return re.sub(r"^(?:a|an|the)\s+", "", s.strip())

    def match_name(self, s: str) -> Optional[str]:
        return best_match(normalize_text(s), self.person_names)

    def match_room(self, s: str) -> Optional[str]:
        return best_match(normalize_text(s), self.room_names)

    def match_place(self, s: str) -> Optional[Place]:
        s = normalize_text(s)

        r = best_match(s, self.room_names)
        if r:
            return Place(name=r, is_room=True, is_placement=False)

        p = best_match(s, self.placement_location_names)
        if p:
            return Place(name=p, is_room=False, is_placement=True)

        l = best_match(s, self.location_names)
        if l:
            return Place(name=l, is_room=False, is_placement=(l in self.placement_location_names))

        return None

    def match_object_or_category(self, s: str) -> Optional[str]:
        s = normalize_text(s).replace("_", " ").strip()
        s = self._strip_articles(s)

        o = best_match(s, self.object_names)
        if o:
            return o

        c = best_match(s, self.object_categories_plural)
        if c:
            return c
        c = best_match(s, self.object_categories_singular)
        if c:
            return c

        return None

    # ---------- public ----------

    def parse(self, text: str) -> ParseResult:
        clauses = split_into_clauses(text)
        steps: List[GpsrStep] = []
        kind: Optional[str] = None

        for clause in clauses:
            ss, k = self._parse_clause_multi(clause)
            if ss:
                steps.extend(ss)
                kind = k or kind

        ok = bool(steps)
        return ParseResult(
            ok=ok,
            need_confirm=not ok,
            intent_type="",           # node側で action hint から補完
            command_kind=(kind or ""),  # eval向けに一応入れる
            steps=steps,
        )

    # ---------- internal ----------

    def _parse_clause_multi(self, clause: str) -> Tuple[List[GpsrStep], Optional[str]]:
        """
        1 clause から複数 step を作れる版。
        典型： "get it and bring it to me"
        """
        c = clause.strip().strip(".")
        if not c:
            return [], None

        m = re.match(r"^(get it|take it|grab it|pick it up|get them|take them|grab them)\s+and\s+(.+)$", c)
        if m:
            first = m.group(1).strip()
            rest = m.group(2).strip()

            steps: List[GpsrStep] = []
            s1, k1 = self._parse_clause(first)
            if s1:
                steps.append(s1)
            s2, k2 = self._parse_clause(rest)
            if s2:
                steps.append(s2)

            return steps, (k2 or k1 or "takeObj")

        s, k = self._parse_clause(c)
        return ([s] if s else []), k

    def _parse_clause(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        c = clause.strip().strip(".")
        if not c:
            return None, None

        # order matters (specific -> generic)
        for fn in [
            # ---- it/them delivery ----
            self._parse_bring_it_to_me,
            self._parse_bring_it_to_person_in_room,

            # ---- A: follow/take/escort/lead family (NEW) ----
            self._parse_follow_name_from_to,
            self._parse_follow_person_with_attribute_at_place,
            self._parse_follow_name_at_place,
            self._parse_take_name_from_to,

            # ---- compare / attribute counting ----
            self._parse_compare_object_on_place,
            self._parse_count_people_with_attribute_in_room,
            self._parse_count_objects_on_place,
            self._parse_tell_name_of_person,

            # ---- existing core ----
            self._parse_bring_me_obj_from_place,
            self._parse_find_obj_in_room,
            self._parse_place_obj_on_place,
            self._parse_take_object,
            self._parse_count_people_in_room,
            self._parse_answer_quiz_in_room,
            self._parse_guide_name_from_to,
            self._parse_go_to_location,
        ]:
            s, k = fn(c)
            if s:
                return s, k

        return None, None

    # ===================== parsers =====================

    # ---- bringMeObjFromPlcmt / deliverObjToPrsInRoom (it/them) ----
    def _parse_bring_it_to_me(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        if clause in (
            "bring it to me", "bring them to me",
            "give it to me", "give them to me",
            "deliver it to me", "deliver them to me",
            "hand it to me", "hand them to me",
        ):
            return GpsrStep(action="bring_object_to_operator", fields={}), "bringMeObjFromPlcmt"

        m = re.search(r"^(?:bring|deliver|give|hand)\s+(it|them)\s+to\s+me$", clause)
        if m:
            return GpsrStep(action="bring_object_to_operator", fields={}), "bringMeObjFromPlcmt"
        return None, None

    def _parse_bring_it_to_person_in_room(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        m = re.search(r"^(?:bring|deliver|give|hand)\s+(it|them)\s+to\s+(.+?)\s+in the\s+(.+)$", clause)
        if not m:
            return None, None
        name = self.match_name(m.group(2).strip())
        room = self.match_room(m.group(3).strip())
        if not room:
            return None, None
        fields: Dict[str, Any] = {"room": room}
        if name:
            fields["name"] = name
        return GpsrStep(action="deliver_object_to_person_in_room", fields=fields), "deliverObjToPrsInRoom"

    # ---- A: follow/take/escort/lead family (NEW) ----

    def _parse_follow_name_from_to(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "follow paris from the shelf to the kitchen"
        m = re.search(r"^(?:follow)\s+(.+?)\s+from the\s+(.+?)\s+to the\s+(.+)$", clause)
        if not m:
            return None, None

        name = self.match_name(m.group(1).strip())
        from_plc = self.match_place(m.group(2).strip())
        to_plc = self.match_place(m.group(3).strip())
        if not from_plc or not to_plc:
            return None, None

        fields: Dict[str, Any] = {"from_place": from_plc, "to_place": to_plc}
        if name:
            fields["name"] = name

        return GpsrStep(action="follow_named_person_from_place_to_place", fields=fields), "followNameFromBeacToBeac"

    def _parse_follow_person_with_attribute_at_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "follow the sitting person at the chairs"
        # "follow the person pointing at the tv stand"
        m = re.search(r"^(?:follow)\s+the\s+(.+?)\s+person\s+at the\s+(.+)$", clause)
        if m:
            attr = m.group(1).strip()
            plc_str = m.group(2).strip()
        else:
            m = re.search(r"^(?:follow)\s+the\s+person\s+(.+?)\s+at the\s+(.+)$", clause)
            if not m:
                return None, None
            attr = m.group(1).strip()
            plc_str = m.group(2).strip()

        plc = self.match_place(plc_str)
        if not plc:
            return None, None

        # attributeは自由入力として保持（視覚/対話側で使う）
        fields = {"place": plc, "person_filter": f"person {attr}"}
        return GpsrStep(action="follow_person_at_place", fields=fields), "followPrsAtBeac"

    def _parse_follow_name_at_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "follow paris at the sink"
        m = re.search(r"^(?:follow)\s+(.+?)\s+at the\s+(.+)$", clause)
        if m:
            name = self.match_name(m.group(1).strip())
            plc = self.match_place(m.group(2).strip())
            if not plc:
                return None, None
            fields: Dict[str, Any] = {"place": plc}
            if name:
                fields["name"] = name
            return GpsrStep(action="follow_named_person_at_place", fields=fields), "followNameAtBeac"

        # "follow paris in the kitchen"
        m = re.search(r"^(?:follow)\s+(.+?)\s+in the\s+(.+)$", clause)
        if not m:
            return None, None
        name = self.match_name(m.group(1).strip())
        room = self.match_room(m.group(2).strip())
        if not room:
            return None, None
        fields = {"room": room}
        if name:
            fields["name"] = name
        return GpsrStep(action="follow_named_person_in_room", fields=fields), "followNameInRoom"

    def _parse_take_name_from_to(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "take jane from the pantry to the armchair"
        # take/lead/escort/guide をまとめる（人を連れて移動）
        m = re.search(r"^(?:take|lead|escort|guide)\s+(.+?)\s+from the\s+(.+?)\s+to the\s+(.+)$", clause)
        if not m:
            return None, None

        name = self.match_name(m.group(1).strip())
        from_plc = self.match_place(m.group(2).strip())
        to_plc = self.match_place(m.group(3).strip())
        if not from_plc or not to_plc:
            return None, None

        fields: Dict[str, Any] = {"from_place": from_plc, "to_place": to_plc}
        if name:
            fields["name"] = name

        # 互換性優先：既存 guide と同じ action に寄せる
        return GpsrStep(action="guide_named_person_from_place_to_place", fields=fields), "guideNameFromBeacToBeac"

    # ---- bringMeObjFromPlcmt ----
    def _parse_bring_me_obj_from_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "bring me a pear from the bedside table"
        m = re.search(r"^(?:bring me|fetch|get|give me)\s+(?:a|an|the)?\s*(.+?)\s+from the\s+(.+)$", clause)
        if not m:
            return None, None

        obj_str = m.group(1).strip()
        plc_str = m.group(2).strip()

        obj = self.match_object_or_category(obj_str)
        plc = self.match_place(plc_str)
        if not plc:
            return None, None

        fields: Dict[str, Any] = {"source_place": plc}
        if obj:
            fields["object"] = obj

        return GpsrStep(action="bring_object_to_operator", fields=fields), "bringMeObjFromPlcmt"

    # ---- findObjInRoom ----
    def _parse_find_obj_in_room(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        if not any(v in clause for v in self.find_verbs):
            return None, None

        m = re.search(
            r"^(?:find|look for|locate|search for)\s+(?:a|an|the)?\s*(.+?)\s+in the\s+(.+)$",
            clause
        )
        if not m:
            return None, None

        obj_str = m.group(1).strip()
        room = self.match_room(m.group(2).strip())
        if not room:
            return None, None

        fields: Dict[str, Any] = {"room": room}

        obj = self.match_object_or_category(obj_str)
        if obj:
            fields["object_or_category"] = obj

        return GpsrStep(action="find_object_in_room", fields=fields), "findObjInRoom"

    # ---- placeObjOnPlcmt ----
    def _parse_place_obj_on_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "put it on the refrigerator"
        m = re.search(r"^(?:put|place)\s+(?:it|them)\s+(?:on|in)\s+the\s+(.+)$", clause)
        if m:
            plc = self.match_place(m.group(1).strip())
            if not plc:
                return None, None
            return GpsrStep(action="place_object_on_place", fields={"place": plc}), "placeObjOnPlcmt"

        # "place a drink on the cabinet"
        m = re.search(r"^(?:put|place)\s+(?:a|an|the)?\s*(.+?)\s+(?:on|in)\s+the\s+(.+)$", clause)
        if not m:
            return None, None

        obj = self.match_object_or_category(m.group(1).strip())
        plc = self.match_place(m.group(2).strip())
        if not plc:
            return None, None

        fields: Dict[str, Any] = {"place": plc}
        if obj:
            fields["object"] = obj

        return GpsrStep(action="place_object_on_place", fields=fields), "placeObjOnPlcmt"

    # ---- takeObj ----
    def _parse_take_object(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        if clause in ("get it", "take it", "grab it", "pick it up", "get them", "take them", "grab them"):
            return GpsrStep(action="take_object", fields={}), "takeObj"

        m = re.search(r"^(?:get|take|grasp|grab)\s+(?:a|an|the)?\s*(.+)$", clause)
        if m and "from the" not in clause and "in the" not in clause:
            obj = self.match_object_or_category(m.group(1).strip())
            if obj:
                return GpsrStep(action="take_object", fields={"object_or_category": obj}), "takeObj"
        return None, None

    # ---- countPrsInRoom ----
    def _parse_count_people_in_room(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        if not any(clause.startswith(p) for p in self.count_prefixes):
            return None, None
        m = re.search(r"(?:tell me how many|how many)\s+(.+?)\s+are in the\s+(.+)$", clause)
        if not m:
            return None, None

        ppl = self._strip_articles(m.group(1).strip())
        room = self.match_room(m.group(2).strip())
        if not room:
            return None, None

        fields = {"room": room, "person_filter_plural": ppl}
        return GpsrStep(action="count_persons_in_room", fields=fields), "countPrsInRoom"

    # ---- countPrsInRoom (with attribute) ----
    def _parse_count_people_with_attribute_in_room(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "tell me how many people in the kitchen are wearing white jackets"
        if not any(clause.startswith(p) for p in self.count_prefixes):
            return None, None

        m = re.search(
            r"(?:tell me how many|how many)\s+people\s+in the\s+(.+?)\s+are wearing\s+(.+)$",
            clause
        )
        if not m:
            return None, None

        room = self.match_room(m.group(1).strip())
        if not room:
            return None, None

        attr = m.group(2).strip().rstrip(".")
        fields = {"room": room, "person_filter_plural": f"people wearing {attr}"}
        return GpsrStep(action="count_persons_in_room", fields=fields), "countPrsInRoom"

    # ---- countObjOnPlcmt ----
    def _parse_count_objects_on_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "tell me how many drinks there are on the bed"
        if not any(clause.startswith(p) for p in self.count_prefixes):
            return None, None

        m = re.search(
            r"(?:tell me how many|how many)\s+(.+?)\s+there are\s+(?:on|in)\s+the\s+(.+)$",
            clause
        )
        if not m:
            return None, None

        obj_str = self._strip_articles(m.group(1).strip())
        plc = self.match_place(m.group(2).strip())
        if not plc:
            return None, None

        obj = self.match_object_or_category(obj_str)
        fields: Dict[str, Any] = {"place": plc}
        fields["object_or_category"] = (obj if obj else obj_str)

        return GpsrStep(action="count_objects_on_place", fields=fields), "countObjOnPlcmt"

    # ---- tellCompareObjOnPlcmt ----
    def _parse_compare_object_on_place(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "tell me what is the smallest fruit on the cabinet"
        if not any(clause.startswith(p) for p in self.tell_prefixes):
            return None, None

        m = re.search(
            r"(?:tell me what is|tell me what)\s+the\s+"
            r"(smallest|largest|biggest|heaviest|lightest|thinnest)\s+"
            r"(.+?)\s+(?:on|in)\s+the\s+(.+)$",
            clause
        )
        if not m:
            return None, None

        comp = m.group(1).strip()
        obj_str = self._strip_articles(m.group(2).strip())
        plc = self.match_place(m.group(3).strip())
        if not plc:
            return None, None

        obj = self.match_object_or_category(obj_str)
        fields: Dict[str, Any] = {"place": plc, "comparison": comp}
        fields["object_or_category"] = (obj if obj else obj_str)

        return GpsrStep(action="compare_object_on_place", fields=fields), "tellCompareObjOnPlcmt"

    # ---- tellNameOfPerson ----
    def _parse_tell_name_of_person(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "tell me the name of the person in the office"
        # "tell me the name of the person at the tv stand"
        if not any(clause.startswith(p) for p in self.tell_prefixes):
            return None, None

        m = re.search(r"^tell me the name of the person\s+(in the|at the)\s+(.+)$", clause)
        if not m:
            return None, None

        prep = m.group(1)
        place_str = m.group(2).strip()

        if prep == "in the":
            room = self.match_room(place_str)
            if not room:
                return None, None
            fields = {"room": room, "person_filter": "person", "question_type": "name"}
            return GpsrStep(action="answer_to_person_in_room", fields=fields), "answerToPrsInRoom"

        plc = self.match_place(place_str)
        if not plc:
            return None, None
        fields = {"place": plc, "person_filter": "person", "question_type": "name"}
        return GpsrStep(action="tell_name_of_person_at_place", fields=fields), "tellNameOfPersonAtPlc"

    # ---- answerToPrsInRoom ----
    def _parse_answer_quiz_in_room(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        if clause in ("answer a question", "answer a quiz", "answer the question", "answer the quiz"):
            return GpsrStep(action="answer_to_person_in_room", fields={}), "answerToPrsInRoom"

        m = re.search(
            r"^(?:answer)\s+(?:a|the)?\s*(question|quiz)"
            r"(?:\s+of\s+the\s+(.+?)\s+in the\s+(.+))?$",
            clause
        )
        if not m:
            return None, None

        if m.group(3):
            room = self.match_room(m.group(3).strip())
            if room:
                return GpsrStep(action="answer_to_person_in_room", fields={"room": room}), "answerToPrsInRoom"

        return GpsrStep(action="answer_to_person_in_room", fields={}), "answerToPrsInRoom"

    # ---- guideNameFromBeacToBeac ----
    def _parse_guide_name_from_to(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "guide jules from the sink to the sofa"
        m = re.search(r"^(?:guide|lead|escort)\s+(.+?)\s+from the\s+(.+?)\s+to the\s+(.+)$", clause)
        if not m:
            return None, None

        name = self.match_name(m.group(1).strip())
        from_plc = self.match_place(m.group(2).strip())
        to_plc = self.match_place(m.group(3).strip())
        if not from_plc or not to_plc:
            return None, None

        fields: Dict[str, Any] = {"from_place": from_plc, "to_place": to_plc}
        if name:
            fields["name"] = name

        return GpsrStep(action="guide_named_person_from_place_to_place", fields=fields), "guideNameFromBeacToBeac"

    # ---- goToLoc ----
    def _parse_go_to_location(self, clause: str) -> Tuple[Optional[GpsrStep], Optional[str]]:
        # "go to the refrigerator"
        m = re.search(r"^(?:go to|navigate to|move to)\s+the\s+(.+)$", clause)
        if not m:
            return None, None

        plc = self.match_place(m.group(1).strip())
        if not plc:
            return None, None

        return GpsrStep(action="go_to_location", fields={"location": plc}), "goToLoc"


if __name__ == "__main__":
    # quick smoke test (not exhaustive)
    v = dict(
        person_names=["Adel", "Angel", "Axel", "Charlie", "Jane", "Jules", "Morgan", "Paris", "Robin", "Simone"],
        room_names=["bedroom", "kitchen", "office", "living room", "bathroom"],
        location_names=["bed", "sink", "cabinet", "refrigerator", "tv stand", "shelf", "pantry", "armchair", "chairs"],
        placement_location_names=["bed", "sink", "cabinet", "refrigerator", "tv stand", "shelf", "pantry", "armchair", "chairs"],
        object_names=["apple", "pear", "red wine"],
        object_categories_plural=["drinks", "fruits", "toys"],
        object_categories_singular=["drink", "fruit", "toy"],
    )
    p = GpsrParser(**v)
    tests = [
        "Tell me how many people in the kitchen are wearing white jackets.",
        "Tell me what is the smallest fruit on the cabinet.",
        "Tell me how many drinks there are on the bed.",
        "Follow Paris from the shelf to the kitchen.",
        "Follow the sitting person at the chairs.",
        "Take Jane from the pantry to the armchair.",
    ]
    for t in tests:
        print(t, "->", p.parse(t).to_dict())

